# storage/table.go 详细分析文档

## 概述
这个文件实现了基于Key-Value存储构建关系型数据库表的核心功能。它是一个完整的关系型数据库存储引擎，将传统的表、行、列概念映射到底层的KV存储上。

## 核心架构：从KV存储到关系型数据库

### 1. 分层设计

```
┌─────────────────────────────┐
│   关系型数据库API层          │  ← Insert, Update, Delete, Scan
├─────────────────────────────┤
│   表结构和索引管理层         │  ← TableDef, 索引选择, 类型检查
├─────────────────────────────┤
│   键值编码/解码层           │  ← 保序编码, 前缀管理, 转义处理
├─────────────────────────────┤
│   底层KV存储引擎            │  ← B+树, 事务, Put/Get/Delete
└─────────────────────────────┘
```

## 数据结构分析

### DB - 数据库实例
```go
type DB struct {
    Path string                    // 数据库文件路径
    kv     KV                     // 底层KV存储引擎（B+树实现）
    mu     sync.Mutex             // 保护表结构缓存的互斥锁
    tables map[string]*TableDef   // 表结构缓存，避免重复读取磁盘
}
```

**作用**：
- 封装底层KV存储，提供数据库级别的操作接口
- 维护表结构缓存，提高查询性能
- 管理数据库的生命周期（打开/关闭）

### DBTX - 数据库事务
```go
type DBTX struct {
    kv KVTX  // 底层KV事务
    db *DB   // 关联的数据库实例
}
```

**作用**：
- 封装KV事务，提供表级别的事务操作
- 保证ACID特性，支持原子性操作

### TableDef - 表结构定义
```go
type TableDef struct {
    Name    string     // 表名
    Types   []uint32   // 列类型数组
    Cols    []string   // 列名数组
    Indexes [][]string // 索引定义（第一个是主键）
    Prefixes []uint32  // 系统分配的前缀
}
```

**关键设计**：
- `Indexes[0]` 始终是主键
- `Prefixes` 为每个索引分配唯一前缀，实现命名空间隔离
- 索引自动包含主键列，确保唯一性

### Record - 表记录
```go
type Record struct {
    Cols []string  // 列名数组
    Vals []Value   // 对应的值数组
}
```

**作用**：
- 表示关系型数据库中的一行记录
- 支持动态列结构，便于查询结果的组装

## 核心算法：保序编码

### 1. 整数编码（符号位翻转）
```go
func encodeInt64(val int64) []byte {
    // 关键：符号位翻转 + 大端序
    u := uint64(val) + (1 << 63)  // 加上2^63
    return bigEndianBytes(u)      // 大端序存储
}
```

**原理**：
- 负数加上2^63后变小，正数变大
- 使得 -∞ < -1 < 0 < 1 < +∞ 的字典序成立
- 例如：-1 → 7FFFFFFFFFFFFFFF，0 → 8000000000000000

### 2. 字符串编码（转义处理）
```go
func escapeString(s []byte) []byte {
    // 转义规则：
    // 0x00 → 0x01 0x01  (空字节)
    // 0x01 → 0x01 0x02  (转义字符本身)
    // 最后添加 0x00 作为终止符
}
```

**目的**：
- 防止字符串中的空字节干扰字段分隔
- 保持字符串的字典序不变
- 确保编码后的键值安全

## 关键映射：关系型→KV

### 主表数据映射
```
关系型记录: {id: 123, name: "Alice", age: 25}
           ↓
KV存储: 
  Key: [表前缀:100][主键编码:123]
  Val: [非主键编码:"Alice",25]
```

### 二级索引映射
```
name索引: {name: "Alice", id: 123}
         ↓
KV存储:
  Key: [索引前缀:101][name:"Alice"][主键:123]
  Val: 空 (索引不存储数据，只存键)
```

## 前缀系统 - 命名空间隔离

```
系统表:
├── @meta表   → 前缀: 1  (存储元数据)
└── @table表  → 前缀: 2  (存储表定义)

用户表 "users":
├── 主键索引   → 前缀: 100
├── name索引   → 前缀: 101  
└── age索引    → 前缀: 102

用户表 "orders":
├── 主键索引   → 前缀: 103
└── user_id索引 → 前缀: 104
```

**优势**：
- 在单个B+树中存储多个表和索引的数据
- 避免键冲突，实现完美的命名空间隔离
- 支持高效的前缀扫描

## 关键操作分析

### 1. 表创建（TableNew）
```go
func (tx *DBTX) TableNew(tdef *TableDef) error {
    // 1. 校验表结构
    // 2. 检查表名冲突  
    // 3. 分配前缀（从@meta表获取计数器）
    // 4. 更新前缀计数器
    // 5. 持久化表定义到@table表
}
```

**前缀分配机制**：
- 从@meta表的"next_prefix"字段获取下一个可用前缀
- 为表的每个索引分配连续的前缀编号
- 更新计数器，为未来的表预留编号

### 2. 数据插入（dbUpdate）
```go
func dbUpdate(tx *DBTX, tdef *TableDef, dbreq *DBUpdateReq) (bool, error) {
    // 1. 重排列顺序（主键在前）
    // 2. 更新主表数据
    // 3. 维护二级索引一致性
    //    - 如果是更新：先删除旧索引
    //    - 添加新索引键
}
```

**索引维护策略**：
- 主表更新时，同步更新所有相关索引
- 更新操作需要先删除旧索引，再添加新索引
- 利用底层事务保证操作的原子性

### 3. 范围查询（dbScan）
```go
func dbScan(tx *DBTX, tdef *TableDef, req *Scanner) error {
    // 1. 索引选择：找到覆盖查询键前缀的索引
    // 2. 编码范围边界键
    // 3. 创建KV迭代器进行扫描
}
```

**索引选择算法**：
- 查找能够覆盖查询键前缀的索引
- 例如：查询["name"]可以使用["name", "id"]索引
- 优先选择最精确匹配的索引

### 4. 主键查询（dbGet）
```go
func dbGet(tx *DBTX, tdef *TableDef, rec *Record) (bool, error) {
    // 构造相同的起始和结束键，实现精确查找
    // 本质上是特殊的范围查询（单点查询）
}
```

## 系统表设计 - 自举机制

### @meta表 - 系统元数据
```
结构: (key TEXT, val BLOB)
数据:
├── "next_prefix" → "106" (下一个可用前缀)
└── "db_version" → "1.0"  (数据库版本)
```

### @table表 - 表定义存储
```
结构: (name TEXT, def JSON)  
数据:
├── "users"  → {"name":"users", "cols":["id","name"], ...}
└── "orders" → {"name":"orders", "cols":["id","user_id"], ...}
```

**自举特性**：
- 数据库用自己的表来存储自己的元数据
- 系统表使用固定前缀，不参与前缀分配
- 实现完全自描述的数据库系统

## 查询执行流程

### 主键点查询
```sql
SELECT * FROM users WHERE id = 123
```
执行流程：
1. 编码查询键：[前缀100][123的编码]
2. KV.Get(查询键)
3. 解码返回的值部分
4. 组合成完整记录返回

### 二级索引范围查询
```sql  
SELECT * FROM users WHERE age BETWEEN 20 AND 30
```
执行流程：
1. 选择age索引（前缀102）
2. 编码范围：[102][20编码] 到 [102][30编码]
3. KV.Scan(起始键, 结束键)
4. 对每个索引记录：
   - 解码得到主键值
   - 用主键回表查询完整记录
5. 返回结果集

### 复合索引查询
```sql
SELECT * FROM users WHERE name = "Alice" AND age > 25  
```
执行流程：
1. 查找覆盖["name", "age"]前缀的索引
2. 如果存在["name", "age", "id"]索引，直接使用
3. 否则降级到["name"]索引，然后过滤age条件

## 事务和一致性

### ACID特性保证
- **原子性**：基于底层KV事务，要么全部成功，要么全部失败
- **一致性**：索引和主表同步更新，维护引用完整性
- **隔离性**：依赖底层KV存储的隔离级别
- **持久性**：事务提交后，数据持久化到磁盘

### 索引一致性维护
```go
// 更新操作的完整流程
1. 更新主表记录
2. if 是更新操作 {
       删除旧记录的所有索引键
   }
3. 添加新记录的所有索引键
4. 如果任何步骤失败 → 回滚整个事务
```

## 高级特性

### 1. 表结构缓存
- 三级查找：内置表 → 内存缓存 → 磁盘加载
- 避免频繁的系统表查询
- 支持并发安全的缓存更新

### 2. 数据导入导出
- **导出**：表结构+数据的完整快照
- **导入**：从快照恢复完整数据库
- 支持跨环境的数据迁移

### 3. 动态索引
- 索引定义存储在表结构中
- 支持运行时的索引管理
- 自动维护索引的完整性

## 性能考虑

### 优化策略
1. **前缀扫描**：利用B+树的前缀查找特性
2. **保序编码**：确保范围查询的高效性
3. **索引选择**：自动选择最优索引减少扫描范围
4. **缓存机制**：表结构缓存减少I/O开销

### 局限性
1. **回表开销**：二级索引查询需要回表
2. **键长度限制**：受底层KV存储的键长度限制
3. **无查询优化器**：索引选择相对简单

## 总结

这个实现展示了如何在简单的KV存储基础上构建功能完整的关系型数据库。核心思想是：

1. **保序编码**：让字典序等于逻辑序，支持高效范围查询
2. **前缀隔离**：在单个B+树中管理多表多索引数据
3. **索引设计**：二级索引包含主键，支持唯一键和回表
4. **系统表**：数据库的自描述和自举能力
5. **事务支持**：基于底层KV事务的ACID保证

这种设计在简单性、性能和功能完整性之间找到了很好的平衡点，是分布式数据库（如TiDB）存储层的经典实现模式。
